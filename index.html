<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">

<style>
html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    background: transparent;
    overflow: hidden;

    /* üî• BLOQUEIA SELE√á√ÉO */
    user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;

    pointer-events: none;
}

.controls {
    position: absolute;
    bottom: 30px;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 14px;

    pointer-events: auto;
}

button {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    background: rgba(255,255,255,0.95);
    font-size: 22px;
    cursor: pointer;

    user-select: none;
    -webkit-user-select: none;
}

/* c√¢mera invis√≠vel */
video {
    position: absolute;
    width: 1px;
    height: 1px;
    opacity: 0;
}
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>

<div class="controls">
    <button onmousedown="btn(event,'SWITCH')">üîÑ</button>
    <button onmousedown="btn(event,'PHOTO')">üì∏</button>
    <button onmousedown="btn(event,'START')">üé•</button>
    <button onmousedown="btn(event,'STOP')">‚èπ</button>
    <button onmousedown="btn(event,'CLOSE')">‚ùå</button>
</div>

<script>
let video = document.getElementById("video");
let stream = null;
let recorder = null;
let chunks = [];
let facing = "user";

async function startCamera() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: facing },
        audio: true
    });
    video.srcObject = stream;
}
startCamera();

function btn(e, action) {
    e.preventDefault();   // üî• evita sele√ß√£o
    e.stopPropagation();  // üî• evita drag

    if (action === "SWITCH") {
        facing = facing === "user" ? "environment" : "user";
        startCamera();
        return;
    }

    if (action === "START") {
        recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
        chunks = [];
        recorder.ondataavailable = ev => chunks.push(ev.data);
        recorder.start();
        return;
    }

    if (action === "STOP" && recorder) {
        recorder.stop();
        recorder.onstop = () => {
            let blob = new Blob(chunks, { type: "video/webm" });
            download(blob, "video_" + Date.now() + ".webm");
            send("VIDEO");
        };
        return;
    }

    if (action === "PHOTO") {
        let c = document.createElement("canvas");
        c.width = video.videoWidth;
        c.height = video.videoHeight;
        c.getContext("2d").drawImage(video, 0, 0);
        c.toBlob(b => {
            download(b, "photo_" + Date.now() + ".png");
            send("PHOTO");
        });
        return;
    }

    if (action === "CLOSE") {
        send("CLOSE");
    }
}

function send(ev) {
    window.location.href = "cef://" + ev;
}

function download(blob, filename) {
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
}
</script>

</body>
</html>
